import { watch, type FSWatcher } from 'chokidar'
import { BrowserWindow } from 'electron'
import fs from 'fs'
import path from 'path'
import ignore, { type Ignore } from 'ignore'
import type { FileNode } from '@main/models/types'

const IMAGE_EXTS = new Set(['png', 'jpg', 'jpeg', 'gif', 'webp', 'ico', 'bmp', 'avif'])
const BINARY_EXTS = new Set([
  ...IMAGE_EXTS, 'svg',
  'woff', 'woff2', 'ttf', 'eot', 'otf',
  'pdf', 'zip', 'tar', 'gz',
  'mp3', 'mp4', 'mov', 'avi', 'wav'
])

export interface FileReadResult {
  content: string
  isBinary: boolean
}

function getExt(filePath: string): string {
  return path.extname(filePath).slice(1).toLowerCase()
}

let watcher: FSWatcher | null = null
let currentRoot: string | null = null
const fileDebounce = new Map<string, NodeJS.Timeout>()

function loadGitignore(rootPath: string): Ignore {
  const ig = ignore()
  ig.add(['.git', 'node_modules', '.DS_Store'])
  const gitignorePath = path.join(rootPath, '.gitignore')
  try {
    const content = fs.readFileSync(gitignorePath, 'utf-8')
    ig.add(content)
  } catch {
    // no .gitignore
  }
  return ig
}

export function readTree(rootPath: string, maxDepth: number = 10): FileNode {
  const ig = loadGitignore(rootPath)

  function walk(dirPath: string, depth: number): FileNode[] {
    if (depth > maxDepth) return []

    let entries: fs.Dirent[]
    try {
      entries = fs.readdirSync(dirPath, { withFileTypes: true })
    } catch {
      return []
    }

    const nodes: FileNode[] = []
    for (const entry of entries) {
      const rel = path.relative(rootPath, path.join(dirPath, entry.name))
      if (ig.ignores(rel)) continue

      const fullPath = path.join(dirPath, entry.name)
      const isDir = entry.isDirectory()

      nodes.push({
        name: entry.name,
        path: fullPath,
        isDirectory: isDir,
        children: isDir ? walk(fullPath, depth + 1) : undefined
      })
    }

    return nodes.sort((a, b) => {
      if (a.isDirectory !== b.isDirectory) return a.isDirectory ? -1 : 1
      return a.name.localeCompare(b.name)
    })
  }

  return {
    name: path.basename(rootPath),
    path: rootPath,
    isDirectory: true,
    children: walk(rootPath, 0)
  }
}

export function startWatching(rootPath: string, win: BrowserWindow): void {
  stopWatching()
  currentRoot = rootPath

  const ig = loadGitignore(rootPath)

  watcher = watch(rootPath, {
    ignoreInitial: true,
    ignored: (filePath: string) => {
      const rel = path.relative(rootPath, filePath)
      if (!rel || rel === '.') return false
      return ig.ignores(rel)
    },
    depth: 10,
    persistent: true
  })

  watcher.on('all', (event: string, filePath: string) => {
    if (win.isDestroyed() || !currentRoot) return

    const tree = readTree(currentRoot)
    win.webContents.send('fs:tree-changed', tree)

    if (event === 'change') {
      if (BINARY_EXTS.has(getExt(filePath))) return
      const existing = fileDebounce.get(filePath)
      if (existing) clearTimeout(existing)
      fileDebounce.set(
        filePath,
        setTimeout(() => {
          fileDebounce.delete(filePath)
          if (win.isDestroyed()) return
          try {
            const content = fs.readFileSync(filePath, 'utf-8')
            win.webContents.send('fs:file-changed', filePath, content)
          } catch {
            // file may be temporarily locked during write
          }
        }, 150)
      )
    }
  })
}

export function readFileContents(filePath: string): FileReadResult {
  const ext = getExt(filePath)
  if (IMAGE_EXTS.has(ext)) {
    return { content: fs.readFileSync(filePath).toString('base64'), isBinary: true }
  }
  if (ext === 'svg') {
    return { content: fs.readFileSync(filePath, 'utf-8'), isBinary: true }
  }
  if (BINARY_EXTS.has(ext)) {
    return { content: '', isBinary: true }
  }
  return { content: fs.readFileSync(filePath, 'utf-8'), isBinary: false }
}

export function stopWatching(): void {
  for (const timer of fileDebounce.values()) clearTimeout(timer)
  fileDebounce.clear()
  if (watcher) {
    watcher.close()
    watcher = null
    currentRoot = null
  }
}
